#include "../utils/util.h"#include "../utils/conn.h"#include "../include/serverAPI.h"#include "../include/cacheFile.h"#include "../include/log.h"#include <stdio.h>#include <pthread.h>#include <stdlib.h>#include <unistd.h>#include <string.h>#include <ctype.h>#include <signal.h>#define SIG_RETURN_SYSCALL(r,c,e) if((r=c)==-1) { if(errno == EINTR) {continue;} else {perror(e);exit(errno);} }#define SIG_SYSCALL(c,e) if(c==-1) { if(errno == EINTR) {continue;} else {perror(e);exit(errno);} }//[eliminare]#define N_THREADS 3#define SOCKNAME "./cs_sock"#define MAX_STORAGE_BYTES 10000#define MAX_STORAGE_FILES 10#define FIFO 0#define LOG_FILE "log.txt"volatile sig_atomic_t termina = 0;static void sigHandler(int useless){    termina = 1;}static ServerStorage *storage;static NodoQi *testaPtr = NULL;static NodoQi *codaPtr = NULL;static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;static pthread_cond_t emptyFd = PTHREAD_COND_INITIALIZER;unsigned int updateMaxSelect(int maxFd, fd_set set);static void run_server(int pipeW2M_Read);static void *clientFun(void *pipeW2M_WriteF);void gestioneCoda(int maxFdF, int fd, fd_set *set);void cleanup();void gestioneSegnali();void gestioneRichiesteAPI(int operazioneAPI, int fdAcceptF);int gestioneApi_openFile(int fdAcceptF);int gestioneApi_writeFile(int fdAcceptF);int gestioneApi_readFile(int fdAcceptF);int gestioneApi_copyFileToDir(int fdAcceptF);int gestioneApi_readNFiles(int fdAcceptF);int gestioneApi_appendToFile(int fdAcceptF);int gestioneApi_lockFile(int fdAcceptF);int gestioneApi_unlockFile(int fdAcceptF);int gestioneApi_closeFile(int fdAcceptF);int gestioneApi_removeFile(int fdAcceptF);int gestioneApi_isFilePresent(int fdAcceptF);int gestioneApi_removeClientInfoAPI(int fdAcceptF);size_t gestioneApi_getSizeFileByte(int fdAcceptF);int main(int argc, char *argv[]){    cleanup();    atexit(cleanup);    gestioneSegnali();    storage = createStorage(MAX_STORAGE_BYTES, MAX_STORAGE_FILES, FIFO);    storage->logFile = fopen(LOG_FILE, "w");    storage->logFile = freopen(NULL, "a", storage->logFile);    int pipeW2M[2];    SYSCALL(pipe(pipeW2M), "Errore: pipe(pipeW2M)")    pthread_t threadFd[N_THREADS];    for(int i = 0; i < N_THREADS; i++)    {        THREAD_CREATE(&threadFd[i], NULL, &clientFun, (void *) &pipeW2M[WRITE_END], "Thread setId")    }    run_server(pipeW2M[READ_END]);    SYSCALL(close(pipeW2M[WRITE_END]), "Errore: close(pipeW2M[WRITE_END])")    SYSCALL(close(pipeW2M[READ_END]), "Errore: close(pipeW2M[READ_END])")    for(int i = 0; i < N_THREADS; i++)    {        THREAD_JOIN(threadFd[i], NULL, "Impossibile fare la join: seetId")    }    stampaHash(storage->fileSystem);    stampaStorage(storage);    FCLOSE(storage->logFile)    freeStorage(storage);    freeLista(&testaPtr, &codaPtr); //da mettere controllo errore [controllare]    puts("\nTermina processo");    return 0;}void gestioneSegnali(){    //i segnali da gestire vengono ignorati finché l'handler non è pronto    sigset_t mask, oldmask;    SYSCALL(sigemptyset(&mask), "Errore: sigemptyset(&mask)")    SYSCALL(sigaddset(&mask, SIGINT), "Errore: sigaddset(&mask, SIGINT)")    SYSCALL(sigaddset(&mask, SIGTERM), "Errore: sigaddset(&mask, SIGINT)")    SYSCALL(sigaddset(&mask, SIGQUIT), "Errore: sigaddset(&mask, SIGINT)")    SYSCALL(sigaddset(&mask, SIGHUP), "Errore: sigaddset(&mask, SIGINT)")    //guardare su notion per capire cosa amettere come primo argomento    SYSCALL_NOTZERO(pthread_sigmask(SIG_BLOCK, &mask, &oldmask), "Errore: Spthread_sigmask(SIG_BLOCK, &mask, &oldmask)")    //GESTIONE SIGINT    struct sigaction sigAct;    memset(&sigAct, 0, sizeof(sigAct)); //inizializza a 0 sSigAction (il prof non fa nessun controllo su memset)    sigAct.sa_handler = sigHandler; //registra l'handler    SYSCALL(sigaction(SIGINT, &sigAct, NULL), "Errore sigaction(SIGINT, &sigAct, NULL)") //il 3 campo può essere != NULL    SYSCALL(sigaction(SIGTERM, &sigAct, NULL), "Errore sigaction(SIGINT, &sigAct, NULL)") //il 3 campo può essere != NULL    SYSCALL(sigaction(SIGQUIT, &sigAct, NULL), "Errore sigaction(SIGINT, &sigAct, NULL)") //il 3 campo può essere != NULL    SYSCALL(sigaction(SIGHUP, &sigAct, NULL), "Errore sigaction(SIGINT, &sigAct, NULL)") //il 3 campo può essere != NULL    //ripristino la maschera (se non lo facessi, non riusciarei a gestire i segnali con l'handler)    SYSCALL_NOTZERO(pthread_sigmask(SIG_SETMASK, &oldmask, NULL), "Errore: Spthread_sigmask(SIG_BLOCK, &mask, &oldmask)")}static void run_server(int pipeW2M_Read){    //Socket di connessione    int fdSkt;    RETURN_SYSCALL(fdSkt, socket(AF_UNIX, SOCK_STREAM, 0), "Errore creazione socket - fdSkt")    struct sockaddr_un sckAddr;    strncpy(sckAddr.sun_path, SOCKNAME, MAXBACKLOG);    sckAddr.sun_family = AF_UNIX;    SYSCALL(bind(fdSkt, (struct sockaddr *) &sckAddr, sizeof(sckAddr)), "Errore bind - fdSkt")    SYSCALL(listen(fdSkt, SOMAXCONN), "Errore listen - fdSkt")    //Massimo fd attivo    int maxFd = fdSkt;    //Inizializzazione set    fd_set set, readSet;    FD_ZERO(&set);    FD_SET(fdSkt, &set); //FD_SET imposta a 1 il bit corrispondente a fdSkt    FD_SET(pipeW2M_Read, &set);    if(pipeW2M_Read > maxFd)    {        maxFd = pipeW2M_Read;    }    int fdSkt_accept;    while(termina == 0)    {        readSet = set;        SIG_SYSCALL(select(maxFd + 1, &readSet, NULL, NULL, NULL), "select(fd_num + 1, &rdset, NULL, NULL, NULL)")        for(int i = 0; i <= maxFd; i++)        {            //se in readn, errno = EINTR, allora l'esecuzione ricomincia dal for (o dal while se i > maxFd)            if(termina == 1)            {                BCAST(&emptyFd)                SYSCALL(close(fdSkt), "Errore close - fdSkt")                return;            }            if (FD_ISSET(i, &readSet))            {                if (i == fdSkt)                {                    RETURN_SYSCALL(fdSkt_accept, accept(fdSkt, NULL, 0), "fdSkt_accept = accept(fdSkt, NULL, 0)")                    FD_SET(fdSkt_accept, &set);                    if (fdSkt_accept > maxFd) {                        maxFd = fdSkt_accept;                    }                    continue;                }                if(i == pipeW2M_Read)                {                    int pipeFdSoccket;                    SYSCALL(readn(pipeW2M_Read, &pipeFdSoccket, sizeof(int)), "Errore")                    FD_SET(pipeFdSoccket, &set);                    if(pipeFdSoccket > maxFd)                        maxFd = pipeFdSoccket;                    continue;                }                LOCK(&mutex)                push(&testaPtr, &codaPtr, i);                SIGNAL(&emptyFd)                UNLOCK(&mutex)                FD_CLR(i, &set);                if(i == maxFd)                    maxFd = updateMaxSelect(i, set);            }        }    }    BCAST(&emptyFd)    SYSCALL(close(fdSkt), "Errore close - fdSkt")}static void *clientFun(void *pipeW2M_WriteF){    int pipeW2M_Write = *((int *) pipeW2M_WriteF);    while (termina == 0)    {        LOCK(&mutex)        while (testaPtr == NULL)        {            WAIT(&emptyFd, &mutex)            if(termina == 1)            {                UNLOCK(&mutex)                return NULL;            }        }        int fdAccept = pop(&testaPtr, &codaPtr);        printf("Fd in thread: %d\n\n", fdAccept);        UNLOCK(&mutex)        //leggo l'operazione da svolgere        int operazioneAPI;        int lenghtRead;        RETURN_SYSCALL(lenghtRead, readn(fdAccept, &operazioneAPI, sizeof(int)), "Errore: read(fdSkt_com, buffer, DIM_BUFFER)")        //Il client ha chiuso la connessione:        if(lenghtRead == 0)        {            SYSCALL(removeClientInfo(storage, fdAccept), "Errore"); //Termino tutto perché il file system potrebbe essere in uno stato instabile            SYSCALL(close(fdAccept), "Errore close - fdSkt")            continue;        }        gestioneRichiesteAPI(operazioneAPI, fdAccept);        SYSCALL(write(pipeW2M_Write, &fdAccept, sizeof(int)), "Erroer: write(pipeW2M_Write, &fdAccept, sizeof(int))")        puts("\n------------Esco------------\n");    }    return NULL;}//sceglie le operazioni da svolgere in base alla richiesta ricevutavoid gestioneRichiesteAPI(int operazioneAPI, int fdAcceptF){    switch (operazioneAPI)    {        case API_OPENFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_openFile(fdAcceptF);            //invia eisto della richiesta (successo o insuccesso)            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_OPENFILE: writen()")            break;        case API_WRITEFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_writeFile(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_WRITEFILE: writen()")            break;        case API_READNFILES:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_readNFiles(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_READNFILES: writen()")            break;        case API_READFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_readFile(fdAcceptF);            //la notitifca dell'esito viene fatta in gestioneApi_readFile            break;        case API_APPENDTOFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_appendToFile(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_APPENDTOFILE: writen()")            break;        case API_LOCKFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_lockFile(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_LOCKFILE: writen()")            break;        case API_UNLOCKFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_unlockFile(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_UNLOCKFILE: writen()")            break;        case API_CLOSEFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_closeFile(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_CLOSEFILE: writen()")            break;        case API_REMOVEFILE:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_removeFile(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_REMOVEFILE: writen()")            break;        case API_REMOVE_CLIENT_INFO:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_removeClientInfoAPI(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_REMOVE_CLIENT_INFO: writen()")            break;        case API_ISFILE_PRESENT:            printf("Operazione: %d\n", operazioneAPI);            int esitoAPI = gestioneApi_isFilePresent(fdAcceptF);            SYSCALL(writen(fdAcceptF, &esitoAPI, sizeof(int)), "API_ISFILE_PRESENT: writen()")            break;        case API_COPY_FILE_TODIR:            printf("Operazione: %d\n", operazioneAPI);            gestioneApi_copyFileToDir(fdAcceptF);            SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_WRITEFILE: writen()")            break;        case API_GET_FILE_SIZEBYTE:            printf("Operazione: %d\n", operazioneAPI);            size_t returnValue = gestioneApi_getSizeFileByte(fdAcceptF);            SYSCALL(writen(fdAcceptF, &returnValue, sizeof(size_t)), "API_WRITEFILE: writen()")            break;        default:            puts("gestioneRichiesteAPI: default");            break;    }    stampaHash(storage->fileSystem);    stampaStorage(storage);}int gestioneApi_openFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_openFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_openFile: read()")    printf("pathname: %s\n", pathname);    //Leggo la flag    int flags;    READN(fdAcceptF, &flags, sizeof(int), "gestioneApi_openFile: read()")    printf("flags: %d\n", flags);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(openFileServer(pathname, flags, storage, fdAcceptF) == -1, "", errno)    return 0;}int gestioneApi_readFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_openFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_openFile: read()")    printf("pathname: %s\n", pathname);    char *buf = NULL; //la malloc viene fatta in readFileServer    size_t size;    //ChiamataAPI - in caso di fallimento, non c'è bisogno di fare free(buf).    errno = 0; //errno potrebbe essere stato settato da un'altro client    if(readFileServer(pathname, &buf, &size, storage, fdAcceptF) == -1)    {        //Notifica esito operazione di readFileServer ed esco        SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_WRITEFILE: writen()")        return -1;    }    //Notifica esito operazione di readFileServer    SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_WRITEFILE: writen()")    //Invio size e buf (n caso di fallimento, devo liberare buf)    CSA(writen(fdAcceptF, &size, sizeof(size_t)) == -1, "gestioneApi_readFile: writen", errno, if(buf != NULL) free(buf))    if(buf != NULL)    {        CSA(writen(fdAcceptF, buf, size) == -1, "gestioneApi_readFile: writen", errno, free(buf))        free(buf);    }    //Notifica esito operazione di readFileServer    SYSCALL(writen(fdAcceptF, &errno, sizeof(int)), "API_WRITEFILE: writen()")    return 0;}int gestioneApi_copyFileToDir(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_writeFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_writeFile: read()")    printf("pathname: %s\n", pathname);    //leggo la dimensione della dir    int dirBytes;    READN(fdAcceptF, &dirBytes, sizeof(int), "gestioneApi_writeFile: read()")    //leggo dirname    char dirname[dirBytes];    memset(dirname, '\0', dirBytes-1);    READN(fdAcceptF, dirname, dirBytes, "gestioneApi_writeFile: read()")    printf("dirname: %s\n", dirname);    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(copyFileToDirServer(pathname, dirname, storage, fdAcceptF) == -1, "", errno)    return 0;}int gestioneApi_readNFiles(int fdAcceptF){    //leggo N    int N;    READN(fdAcceptF, &N, sizeof(int), "gestioneApi_openFile: read()")    //Leggo la dimensione di dirname    int dirBytes;    READN(fdAcceptF, &dirBytes, sizeof(int), "gestioneApi_writeFile: read()")    //leggo dirname    char dirname[dirBytes];    memset(dirname, '\0', dirBytes-1);    READN(fdAcceptF, dirname, dirBytes, "gestioneApi_writeFile: read()")    printf("dirname: %s\n", dirname);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(readNFilesServer(N, dirname, storage, fdAcceptF) == -1, "", errno)    return 0;}int gestioneApi_writeFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_writeFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_writeFile: read()")    printf("pathname: %s\n", pathname);    //leggo la dimensione della dir    int dirBytes;    READN(fdAcceptF, &dirBytes, sizeof(int), "gestioneApi_writeFile: read()")    if(dirBytes == ARGUMENT_NULL)    {        //dir è NULL        errno = 0; //errno potrebbe essere stato settato da un'altro client        CS(writeFileServer(pathname, NULL, storage, fdAcceptF) == -1, "", errno)    }    else    {        char dirname[dirBytes];        memset(dirname, '\0', dirBytes-1);        READN(fdAcceptF, dirname, dirBytes, "gestioneApi_writeFile: read()")        printf("dirname: %s\n", dirname);        errno = 0; //errno potrebbe essere stato settato da un'altro client        CS(writeFileServer(pathname, dirname, storage, fdAcceptF) == -1, "", errno)    }    return 0;}int gestioneApi_appendToFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_appendToFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_appendToFile: read()")    printf("pathname: %s\n", pathname);    //Leggo size    size_t size;    READN(fdAcceptF, &size, sizeof(size_t), "gestioneApi_appendToFile: read()")    char buf[size]; //seize comprende il '\0'    memset(buf, '\0', size-1);    READN(fdAcceptF, buf, size, "gestioneApi_appendToFile: read()")    //leggo la dimensione della dir    int dirBytes;    READN(fdAcceptF, &dirBytes, sizeof(int), "gestioneApi_appendToFile: read()")    if(dirBytes == ARGUMENT_NULL)    {        //dir è NULL        errno = 0; //errno potrebbe essere stato settato da un'altro client        CS(appendToFileServer(pathname, buf, size, NULL, storage, fdAcceptF) == -1, "", errno)    }    else    {        char dirname[dirBytes];        memset(dirname, '\0', dirBytes-1);        READN(fdAcceptF, dirname, dirBytes, "gestioneApi_appendToFile: read()")        printf("dirname: %s\n", dirname);        errno = 0; //errno potrebbe essere stato settato da un'altro client        CS(appendToFileServer(pathname, buf, size, dirname, storage, fdAcceptF) == -1, "", errno)    }    return 0;}int gestioneApi_lockFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_openFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_openFile: read()")    printf("pathname: %s\n", pathname);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(lockFileServer(pathname, storage, fdAcceptF) == -1, "", errno)    return 0;}int gestioneApi_unlockFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_unlockFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_unlockFile: read()")    printf("pathname: %s\n", pathname);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(unlockFileServer(pathname, storage, fdAcceptF) == -1, "", errno)    return 0;}int gestioneApi_closeFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_openFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_openFile: read()")    printf("pathname: %s\n", pathname);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(closeFileServer(pathname, storage, fdAcceptF) == -1, "", errno)    return 0;}int gestioneApi_removeFile(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_openFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_openFile: read()")    printf("pathname: %s\n", pathname);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(removeFileServer(pathname, storage, fdAcceptF) == -1, "", errno)    return 0;}int gestioneApi_isFilePresent(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_openFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_openFile: read()")    printf("pathname: %s\n", pathname);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    return isPathPresentServer(pathname, storage, fdAcceptF);}size_t gestioneApi_getSizeFileByte(int fdAcceptF){    //leggo la dimensione del pathname    int pathnameBytes;    READN(fdAcceptF, &pathnameBytes, sizeof(int), "gestioneApi_openFile: read()")    //leggo il pathname    char pathname[pathnameBytes];    memset(pathname, '\0', pathnameBytes-1);    READN(fdAcceptF, pathname, pathnameBytes, "gestioneApi_openFile: read()")    printf("pathname: %s\n", pathname);    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    return getSizeFileByteServer(pathname, storage, fdAcceptF);}int gestioneApi_removeClientInfoAPI(int fdAcceptF){    //ChiamataAPI    errno = 0; //errno potrebbe essere stato settato da un'altro client    CS(removeClientInfo(storage, fdAcceptF) == -1, "", errno)    return 0;}unsigned int updateMaxSelect(int maxFd, fd_set set){    for(int i = maxFd - 1; i >= 0; i--)    {        if(FD_ISSET(i, &set))        {            return i;        }    }    return -1;}void cleanup(){    unlink(SOCKNAME);}